# 150. Evaluate Reverse Polish Notation

[ðŸ§‘ðŸ»â€ðŸ’»ë¬¸ì œ ë°”ë¡œê°€ê¸°](https://leetcode.com/problems/evaluate-reverse-polish-notation/)



## ë¬¸ì œ ìš”ì•½

í›„ìœ„í‘œí˜„ì‹ì´ ë°°ì—´ë¡œ ì£¼ì–´ì§„ë‹¤. í•´ë‹¹ í›„ìœ„í‘œí˜„ì‹ì„ ê³„ì‚°í•˜ì—¬ ê²°ê³¼ê°’ì„ ì¶œë ¥í•˜ë¼.



## ë¬¸ì œ í’€ê¸°

í›„ìœ„í‘œí˜„ì‹ìœ¼ë¡œ ë‚˜ì™€ìžˆê¸° ë•Œë¬¸ì— í•˜ë‚˜ì”© ë¹¼ì„œ ìˆ«ìžê°€ ë‘ ê°œ ê²¹ì³ì§ˆ ë•Œ ê³„ì‚°í•˜ë©´ ëœë‹¤. ì£¼ì–´ì§„ ë°°ì—´ì„ í•˜ë‚˜ì”© `pop`í•˜ë©° ë”°ë¡œ ìŠ¤íƒì— ì¶”ê°€í•´ ë†“ëŠ”ë‹¤. ê·¸ëŸ¬ë©´ ìŠ¤íƒì˜ ë§¨ ìœ— ë¶€ë¶„ì— ìˆ«ìžê°€ ë‘ ê°œì¼ ë•Œê°€ ìƒê¸°ëŠ”ë° ì´ ë•Œ, ë’¤ì˜ ì‚¬ì¹™ì—°ì‚°ê³¼ í•¨ê»˜ ê³„ì‚°í•´ì„œ ë‹¤ì‹œ ìŠ¤íƒì— ë„£ì–´ì£¼ë©´ ëœë‹¤. ì´ë¥¼ ë°˜ë³µí•˜ë‹¤ë³´ë©´ í•˜ë‚˜ì˜ ê°’ì´ ë‚˜ì˜¤ê²Œ ë˜ê³  ê·¸ ê°’ì„ ì¶œë ¥í•œë‹¤.



**ì½”ë“œ**

```ts
function evalRPN(tokens: string[]): number {
    const operations = ["+", "-", "/", "*"]
    const s = []
    while (tokens.length > 0) {
        if (s.length > 2 && !operations.includes(s[s.length-1]) && !operations.includes(s[s.length-2])) {
            const [num1, num2] = [s.pop(), s.pop()]
            const operation = s.pop()
            if (operation === "/") {
                if (num1 / num2 > 0) {
                    s.push(Math.floor(num1 / num2))
                } else {
                    s.push(Math.ceil(num1 / num2))
                }
            }

            if (operation === "*") {
                s.push(num1 * num2)
            }

            if (operation === "+") {
                s.push(num1 + num2)
            }

            if (operation === "-") {
                s.push(num1 - num2)
            }
        } else {
            const x = tokens.pop()
            if (operations.includes(x)) {
                s.push(x)
            } else {
                s.push(Number(x))
            }
        }
    }

    while (s.length > 2) {
        if (!operations.includes(s[s.length-1]) && !operations.includes(s[s.length-2])) {
            const [num1, num2] = [s.pop(), s.pop()]
            const operation = s.pop()
            if (operation === "/") {
                if (num1 / num2 > 0) {
                    s.push(Math.floor(num1 / num2))
                } else {
                    s.push(Math.ceil(num1 / num2))
                }
            }

            if (operation === "*") {
                s.push(num1 * num2)
            }

            if (operation === "+") {
                s.push(num1 + num2)
            }

            if (operation === "-") {
                s.push(num1 - num2)
            }
        }
    }
    return s[0]
};
```

**ì‹œê°„ë³µìž¡ë„** - O(n)

**ê³µê°„ë³µìž¡ë„** - O(n)



---

ìœ„ ì½”ë“œëŠ” ì²˜ìŒ ë§‰ ë§Œë“¤ë‹¤ ë³´ë‹ˆ ë¹„íš¨ìœ¨ì ìœ¼ë¡œ ì½”ë“œê°€ ì§œì¡Œë‹¤. ê·¸ëž˜ì„œ ë°‘ê³¼ ê°™ì´ ìª¼ê°¤ ìˆ˜ ìžˆëŠ” ì½”ë“œë¥¼ ìª¼ê°œê³  ë¡œì§ë¶€ë¶„ì€ ì¢€ ë” ì´í•´ê¸° ì‰½ë„ë¡ êµ¬í˜„í•´ë³´ì•˜ë‹¤. 



**ì½”ë“œ**

```ts
function evalRPN(tokens: string[]): number {
    const operations = ["+", "-", "/", "*"]
    const s = []
    const operate = (operation, num1, num2) => {
        if (operation === "/") {
            if (num1 / num2 > 0) {
                s.push(Math.floor(num1 / num2))
            } else {
                s.push(Math.ceil(num1 / num2))
            }
        } else if (operation === "*") {
            s.push(num1 * num2)
        } else if (operation === "+") {
            s.push(num1 + num2)
        } else if (operation === "-") {
            s.push(num1 - num2)
        }
    }

    const pushS = (x) => {
        if (operations.includes(x)) {
            s.push(x)
        } else {
            s.push(Number(x))
        }
    }

    const isExistedLastTwoNums = () => {
        if (s.length > 2 && !operations.includes(s[s.length-1]) && !operations.includes(s[s.length-2])) {
            return true
        }
        return false
    }

    while (tokens.length !== 0 || s.length > 2) {
        if (isExistedLastTwoNums()) {
            const [num1, num2] = [s.pop(), s.pop()]
            operate(s.pop(), num1, num2)
        } else {
            const x = tokens.pop()
            pushS(x)
        }
    }

    return s[0]
};
```

**ì‹œê°„ë³µìž¡ë„** - O(n)

**ê³µê°„ë³µìž¡ë„** - O(n)



---

ìœ„ì™€ ê°™ì´ ìŠ¤íƒì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì´ ì•„ë‹Œ ê·¸ëƒ¥ ì£¼ì–´ì§„ ë°°ì—´ì„ ì­‰ íƒìƒ‰í•˜ëŠ” ë°©ë²•ë„ ìžˆë‹¤. ë§ˆì§€ë§‰ ê°’ì´ ì—°ì‚°ì´ ë‚˜ì™€ì•¼ ê³„ì‚°í•œë‹¤ëŠ” ì ê³¼ tokensë¥¼ ì •ìˆœíšŒí•œë‹¤ëŠ” ì ì—ì„œ ì¢€ ë‹¤ë¥´ì§€ë§Œ ê±°ì˜ ë¹„ìŠ·í•œ ë°©ì‹ì´ë¼ ë³¼ ìˆ˜ ìžˆë‹¤.



**ì½”ë“œ**

```ts
function evalRPN(tokens: string[]): number {
    const operations = ["+", "-", "/", "*"]
    const s = []

    const operate = (operation, num1, num2) => {
        if (operation === "/") {
            if (num1 / num2 > 0) {
                s.push(Math.floor(num1 / num2))
            } else {
                s.push(Math.ceil(num1 / num2))
            }
        } else if (operation === "*") {
            s.push(num1 * num2)
        } else if (operation === "+") {
            s.push(num1 + num2)
        } else if (operation === "-") {
            s.push(num1 - num2)
        }
    }

    const pushS = (x) => {
        if (operations.includes(x)) {
            s.push(x)
        } else {
            s.push(Number(x))
        }
    }

    for (let i=0; i<tokens.length; i++) {
        pushS(tokens[i])
        while (operations.includes(s[s.length-1])) {
            const operation = s.pop()
            const [num2, num1] = [s.pop(), s.pop()]
            operate(operation, num1, num2)
        }
    }

    return s[0]
};
```

**ì‹œê°„ë³µìž¡ë„** - O(n)

**ê³µê°„ë³µìž¡ë„** - O(n)



### 2ê°€ì§€ í’€ì´ ë°©ë²• ìš”ì•½

* ì£¼ì–´ì§„ ë°°ì—´ì„ í•˜ë‚˜ì”© `pop`ìœ¼ë¡œ ë½‘ìœ¼ë©° ìƒˆë¡œìš´ ìŠ¤íƒì— ì €ìž¥í•˜ì—¬ ê·¸ ìŠ¤íƒì˜ ë§¨ ìœ„ ê°’ ë‘ê°œê°€ ìˆ«ìžì¼ ê²½ìš°, ìƒˆë¡œ ë§Œë“  ìŠ¤íƒì—ì„œ `pop`ì„ ì„¸ë²ˆí•˜ì—¬ ì—°ì‚° í›„, ë‹¤ì‹œ ìŠ¤íƒì— ì§‘ì–´ë„£ëŠ” ì—°ì‚°ì„ ë°˜ë³µí•œë‹¤. ê·¸ë ‡ê²Œ ë‚¨ì€ í•˜ë‚˜ì˜ ìˆ«ìžë¥¼ ë°˜í™˜í•œë‹¤.
* ì£¼ì–´ì§„ ë°°ì—´ì„ ì •ìˆœíšŒí•˜ì—¬ ìƒˆë¡œìš´ ìŠ¤íƒì— ì €ìž¥í•´ ë‘”ë‹¤. ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ê°’ì´ ì—°ì‚°ìžì¼ ê²½ìš°, ì„¸ ë²ˆì˜ `pop`ì„ í†µí•´ ì—°ì‚° í›„, ë‹¤ì‹œ ìŠ¤íƒì— ì§‘ì–´ë„£ëŠ” ì—°ì‚°ì„ ë°°ì—´ ì •ìˆœíšŒ ëë‚  ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤. ê·¸ë ‡ê²Œ ë‚¨ì€ í•˜ë‚˜ì˜ ìˆ«ìžë¥¼ ë°˜í™˜í•œë‹¤.



### ì¢€ ë” ë‚˜ì•„ê°€ê¸°

ë§Žì´ ì°¾ì•„ë´¤ëŠ”ë°, ì´ ë‘ ê°€ì§€ ë°©ë²•ë§ê³ ëŠ” ìƒ‰ë‹¤ë¥¸ ë°©ë²•ì„ ì°¾ì€ ê²ƒì´ ì—†ë‹¤. êµ¬í˜„ë¡œì§ë§Œ ë‹¤ë¥¼ ë¿ì´ì—ˆë‹¤. ì•„ì‰½ì§€ë§Œ ì—¬ê¸°ì„œ ë„ì•!


